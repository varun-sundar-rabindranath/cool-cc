#pragma once

/**
 * Recursive Descent Parser
 * Utilizes the information generated by recursive-descent parser generator
 * build a parse tree.
 * This Parser is grammar agnostic as all the RecursiveDescentParserGenerator
 * produces output that is grammar agnostic
 */

#include <lexer/lexer.hpp>
#include <parser/production.hpp>
#include <parser/parser_node.hpp>
#include <stack>
#include <unordered_map>

enum ParserState {
  PARSER_STATE_PROCESSING = 0,
  PARSER_STATE_FINISHED = 1,
  PARSER_STATE_ERROR = 2,
  PARSER_STATE_INVALID = 3
};

class RecursiveDescentParser {

  private:
    using ProductionID = int;
    // The StackStateEntry is a pair of the ProductionElement and ProductionID
    // - The ProductionElement is the element at the top of the stack
    // - The ProductionID indentifies what production was used to expand
    //   the expand the stack - So the appropriate semantic rule can be
    //   called.
    using StateStackEntry = std::pair<ProductionElement, ProductionID>;

    static const StateStackEntry StackReductionMarker;
    static const ProductionID InvalidProductionID;

  public:
    RecursiveDescentParser();

    ParserState ProcessLexeme(const Lexeme& lexeme);

    ParserState GetParserState() const { return parser_state_; }

  private:

    ParserState parser_state_{PARSER_STATE_INVALID};

    std::stack<StateStackEntry> state_stack_;

    // Need a data store to save all the ParseTreeNodes when reducing production
    std::stack<ParseTreeNodePTR> reduction_store_;

    // Map with Key as ProductionElement::element string and value as the
    // ProductionElement
    std::unordered_map<std::string, ProductionElement> token_production_element_map_;

    // Map with Key as the production id and value as the production itself
    std::unordered_map<std::size_t, Production> id_production_map_;
};
